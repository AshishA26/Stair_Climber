#pragma config(Motor, motorA, MOTOR_FL,   tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor, motorB, MOTOR_BELT, tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor, motorC, MOTOR_BACK, tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor, motorD, MOTOR_FR,   tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//https://robotics.stackexchange.com/questions/751/confused-about-the-variables-in-robotc

/*
	Samuel Ke, Ashish Agrahari, Svamin Bhatnagar, and Jacob Zhuang
	Lego EV3 Group 8-8
	11/03/2023
	Robot Name: Bertha
	Version: 1.0
	Description: Stair Climbing Robot
	Acknowledgements:
		- https://www.robotc.net/files/pdf/lego-natural-language/NL_NXT_Quick.pdf
		- http://cmra.rec.ri.cmu.edu/products/teachingmindstorms/sensing/volumespeed/documents/Sensing_SpeedBasedVolume.pdf
		- https://www.robotc.net/files/pdf/lego-natural-language/NL_TETRIX_Quick.pdf
		- https://www.youtube.com/watch?v=kjoKC0uWtTo&ab_channel=hundredvisionsguy
	- Multiplexer code from learn
  Note: The program assumes common.h, mindsensors-ev3smux.h and UW_sensorMux.c are in the same directory
				as this file.
*/

/*
Constraints:
- Can go up 1, 2, or 3 books
- Can go down 1 book
- Stops at the color green
- Start on left side of books as it turns slightly right

*/

	/*
		S1 Gyro
		S2 Sound
		S3 Touch
		S4 Ultrasonic

		A Front Left Wheel
		B Back Wheel
		C Belt
		D Front Right Wheel
	*/

void configureSensors();
// void driveMotorsFront(int leftPower, int rightPower);
void driveMotorsFrontBack(int motorPowerF,int motorPowerB);
void driveAllMotors(int motorPower);
//void rotateRobot(int angle);
bool climb(int motorPower);
void screamDetected(int soundLevel, float waitTime);
//float measureDist(float waitTime);
void driveDist(int distance, int power);
void pullBeltBackUp(int motorPower);
void moveRobotBackDown(int motorPower);
bool climbAllSteps(bool failedClimb);

// Constants
const int SPEED_SLOW = 20;
//const int SPEED_MID = 25;
const float SOUND_LEVEL = 20;
const float TIME_INTERVAL = 10;
//const int MAX_DIST = 20;
const int CM_TO_ENC = 360 / (2.0 * PI * 3.4);
const int ROBOT_LENGTH = 10;
//const int TURN_SPEED = 10;

task main()
{
	configureSensors();

	// Initialize motor encoders
	nMotorEncoder[MOTOR_FL] = 0;
	nMotorEncoder[MOTOR_BACK] = 0;
	nMotorEncoder[MOTOR_BELT] = 0;
	nMotorEncoder[MOTOR_FR] = 0;

	// Display group and name
	displayString(5, "Group: 8-8,");
	displayString(6, "Robot: 33,");
	displayString(7, "Name: Bertha");

	// Wait until a loud noise is detected
	screamDetected(SOUND_LEVEL, TIME_INTERVAL);

	// Play sound
	//playSoundFile("Blip1");

	// Start climbing
	bool failedClimb = false;
	failedClimb = climbAllSteps(failedClimb);

	// Back away from stair
	if (failedClimb)
	{
		driveDist(5, -SPEED_SLOW);
	}

	// Stop and play sound
	driveMotorsFrontBack(0,0);
	//playSoundFile("Blip1");
}

// Sensor Configuration
void configureSensors()
{
	SensorType[S1] = sensorEV3_Gyro;
	wait1Msec(50);
	SensorMode[S1] = modeEV3Gyro_Calibration;
	wait1Msec(100);
	SensorMode[S1] = modeEV3Gyro_RateAndAngle;
	wait1Msec(50);

	SensorType[S2] = sensorSoundDB;
	wait1Msec(50);

	SensorType[S3] = sensorEV3_Touch;
	wait1Msec(50);

	//SensorType[S4] = sensorEV3_Ultrasonic;
	//wait1Msec(50);

	SensorType[S4] = sensorEV3_Color;
	wait1Msec(50);
	SensorMode[S4] = modeEV3Color_Color;
	wait1Msec(50);
}

// Drive front and back motors at same speed
void driveMotorsFrontBack(int motorPowerF,int motorPowerB)
{
	motor[MOTOR_FR] = motor[MOTOR_FL] = motorPowerF;
	motor[MOTOR_BACK] = -motorPowerB; //Back motor is backwards
	return;
}

// Drive all motors at diff speeds
void driveAllMotors(int motorPower)
{
	motor[MOTOR_FR] = motor[MOTOR_FL] = motorPower;
	motor[MOTOR_BELT] = (int)(motorPower*2);
	motor[MOTOR_BACK] = (int)(-motorPower*0.2); //Back motor is backwards
	return;
}

bool climbAllSteps(bool failedClimb)
{
	do
	{
		// Drive motors until stairs detected
		resetGyro(S1);
		driveMotorsFrontBack(SPEED_SLOW, SPEED_SLOW);
		int newAngle = 5;
		while (getGyroDegrees(S1) < newAngle && SensorValue[S4] != (int)colorGreen)
		{
			displayBigTextLine(3,"Gyro is %d", getGyroDegrees(S1));
		}

		if (SensorValue[S4] != (int)colorGreen)
		{
			displayBigTextLine(5,"Ready to climb");

			failedClimb = climb(SPEED_SLOW);
		}

		// While the robot has not cleared the stair and has not reached max height
	} while (!failedClimb && SensorValue[S4] != (int)colorGreen);

	return failedClimb;
}

// Climb robot
bool climb(int motorPower)
{
	nMotorEncoder[MOTOR_BELT] = 0;
	driveAllMotors(motorPower);

	// While stair not cleared and max height not reached
	while (getGyroDegrees(S1)>-5 && SensorValue[S3] == 0)
	{
		displayBigTextLine(3,"Gyro is %d", getGyroDegrees(S1));
	}

	// Failed to climb, go back down
	if (SensorValue[S3] == 1)
	{
		displayBigTextLine(5,"Failed, going down");
		moveRobotBackDown(motorPower);
		return true;
	}
	// Drive robot forward and pull up belt
	else
	{
		displayBigTextLine(5,"Going forward 10cm");
		motor[MOTOR_BELT]=0;
		driveDist(ROBOT_LENGTH, motorPower);

		displayBigTextLine(5,"Pulling belt up");
		driveMotorsFrontBack(motorPower+5, motorPower);
		//driveMotorsFrontBack(motorPower, motorPower);
		pullBeltBackUp(SPEED_SLOW);

		return false;
	}
}

// Move robot back down
void moveRobotBackDown(int motorPower)
{
	driveAllMotors(-motorPower);
	while (abs(nMotorEncoder[MOTOR_BELT]) > 0)
	{}
	driveAllMotors(0);
}

// Pull belt back up
void pullBeltBackUp(int motorPower)
{
	motor[MOTOR_BELT] = -motorPower;
	while (abs(nMotorEncoder[MOTOR_BELT]) > 0)
	{}
	motor[MOTOR_BELT] = 0;
}

// Measure sound
void screamDetected(int soundLevel, float waitTime)
{
	float average = 0;
	while (average < soundLevel)
	{
		time1[T1] = 0;
		while (time1[T1] < waitTime)
		{}
		int reading1 = SensorValue(S2);
		while (time1[T1] < waitTime * 2)
		{}
		int reading2 = SensorValue(S2);
		while (time1[T1] < waitTime * 3)
		{}
		int reading3 = SensorValue(S2);
		average = (float)(reading1 + reading2 + reading3) / 3.0;
	}
}

// Drive a given distance
void driveDist(int distance, int power)
{
	nMotorEncoder[MOTOR_FL] = 0;
	float distToDrive = distance * CM_TO_ENC;
	driveMotorsFrontBack(power, power);
	while (abs(nMotorEncoder[MOTOR_FL]) < distToDrive)
	{}
	driveMotorsFrontBack(0,0);
}

// Measure ultrasonic distance
//float measureDist(float waitTime)
//{
//	float average = 0;
//	time1[T1] = 0;
//	while (time1[T1] < waitTime)
//	{}
//	int reading1 = SensorValue(S4);
//	while (time1[T1] < waitTime * 2)
//	{}
//	int reading2 = SensorValue(S4);
//	while (time1[T1] < waitTime * 3)
//	{}
//	int reading3 = SensorValue(S4);
//	average = (float)(reading1 + reading2 + reading3) / 3.0;
//	return average;
//}



// Drive only front motors (can be used for turning)
// void driveMotorsFront(int leftPower, int rightPower)
// {
// 	motor[MOTOR_FR] = rightPower;
// 	motor[MOTOR_FL] = leftPower;
// 	return;
// }

// // Rotate robot
// void rotateRobot(int angle)
// {
// 	int prevAngle = getGyroDegrees(S2);
// 	int newAngle = prevAngle + angle;
// 	if (angle > 0)
// 	{
// 		driveMotorsFront(-TURN_SPEED, TURN_SPEED);
// 		while (readMuxSensor(msensor_S1_2) < newAngle)
// 		{}
// 	}
// 	else
// 	{
// 		driveMotorsFront(TURN_SPEED, -TURN_SPEED);
// 		while (readMuxSensor(msensor_S1_2) > newAngle)
// 		{}
// 	}
// 	driveMotorsFront(0, 0);
// 	return;
// }
